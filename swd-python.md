---

class: inverse, center, middle

# Felületi tesztelés Seleniummal

---

## Selenium

* Böngésző automatizálás, tipikusan webes alkalmazások tesztelésére
* Eszközkészlet, több eszközből áll


![Selenium logo](images/selenium-logo.png)

---

## Selenium tulajdonságai

* Platformfüggetlen (Windows, Apple OS X, Linux, pl. Ubuntu)
* Képes meghajtani a különböző böngészőket is (Firefox, Internet Explorer, Safari, Opera, Chrome)
* Nyílt forráskódú, ingyenes

![Selenium logo](images/browsers_200.png)

---

## Felhasználási területek

* Funkcionális tesztelés
* GUI tesztelés
* Regressziós tesztelés
* Böngészőfüggetlenség tesztelése

![Selenium felhasználási területek](images/usage_200x.png)

---

## Selenium helye a tesztpiramisban

* E2E tesztelés
* GUI oldalról
* E2E tesztelés erőforrásigényes teszt készítés és teszt futtatás szempontjából is
    * Rendszer tesztelése a környezetével integrálva
    * Környezet megfelelő állapotban van?
    * Böngészők, virtuális ablakozó rendszer
    * Lassú
* Ne függj törékeny, gyakran változó dolgoktól, mint a GUI
    * Fragile Test Problem - változik a GUI, változtatni kell a teszteseteket

---

## Selenium alkalmazási területei

* Ha kevés teljes folyamaton átívelő, több lépésből álló E2E
tesztem van, ami a core üzleti funkcionalitást teszteli (happy path), (sanity)
* Megkérdőjelezhetőek a klasszikus alapelvek:
    * Egy teszt egy dolgot tesztel, egy dologra ellenőrzök
        * Több lépés esetén több ellenőrzés
* Ha nem törik el: jön a pénz
* Ha eltörik: nem jön a pénz

---

## Alternatívák

* Robot Framework
* Cypress
* Katalon Studio
* Protractor: Angular környezetben
* Ranorex (kereskedelmi)
* MicroFocus UFT (Unified Functional Test) (kereskedelmi)
* SikuliX
* RAPISE by Inflectra (kereskedelmi)
* SmartBear TestComplete (kereskedelmi)

---

## Eszközök

* Selenium IDE: felvétel és visszajátszás grafikus felületen
* Selenium WebDriver: böngészővezérlés (pl. programozási nyelvekből API-n keresztül)
* Selenium Grid: automatizált tesztelés több gépről, összehangoltan

![Selenium tools](images/tools_400x.png)

---

class: inverse, center, middle

# Bevezetés a WebDriver használatába

---

## Selenium IDE

* Felvétel és visszajátszás (tesztesetek lépésekkel)
* Chrome vagy FireFox Add-On
* Programozási nyelv funkciók: parancskészlet, paraméterezés, változók, vezérlési elemek
* IDE funkciók, pl. projektkezelés, autocomplete, debug
* Parancssori futtatási lehetőség

---

## Export Python pytest

```python
# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

class TestPep():
  def setup_method(self, method):
    self.driver = webdriver.Chrome()
    self.vars = {}
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def test_pep(self):
    self.driver.get("https://www.python.org/")
    self.driver.set_window_size(908, 830)
    self.driver.find_element(By.CSS_SELECTOR, ".options-bar-container").click()
    self.driver.find_element(By.ID, "id-search-field").click()
    self.driver.find_element(By.ID, "id-search-field").send_keys("pep")
    self.driver.find_element(By.ID, "submit").click()
    assert self.driver.find_element(By.LINK_TEXT, "PEP 1 -- PEP Purpose and Guidelines").text == "PEP 1 -- PEP Purpose and Guidelines"
  
```

---

## Selenium WebDriver

* Böngészővezérlés programozottan
* Különböző programozási nyelvekhez illesztés: C#, Groovy, Java, Perl, PHP, Python, Ruby and Scala
* Driver böngészőnként 
  * Firefoxhoz geckodriver, https://github.com/mozilla/geckodriver
  * Chromehoz ChromeDriver, https://chromedriver.chromium.org/
* W3C WebDriver standard, https://w3c.github.io/webdriver/webdriver-spec.html

---

## WebDriver

![WebDriver](images/webdriver_500x.png)

---

## Selenium WebDriver

* https://github.com/SeleniumHQ/selenium/tree/trunk/py
* selenium-java 4.0.0 2021. október 13.

---

## Új Python projekt

`requirements.txt`

```
selenium
pytest
```

Parancsok:

```shell
python -m venv venv
pip install -r requirements.txt
webdriver-manager
```

---

## Első Python script

```python
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

from selenium.webdriver.common.by import By

driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
driver.get("https://python.org")
driver.find_element(By.ID, "id-search-field").send_keys("pep")
driver.find_element(By.ID, "submit").click()
```

---

## Első pytest teszteset

`python_site_test.py`

```python
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

from selenium.webdriver.common.by import By

def test_pep():
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
    driver.get("https://python.org")
    driver.find_element(By.ID, "id-search-field").send_keys("pep")
    driver.find_element(By.ID, "submit").click()
    assert driver.find_element(By.LINK_TEXT, "PEP 1 -- PEP Purpose and Guidelines").text == "PEP 1 -- PEP Purpose and Guidelines"
```

---

class: inverse, center, middle

# Kódismétlés megszüntetése fixture használatával

---

## Fixture használata

```python
import pytest
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

from selenium.webdriver.common.by import By

@pytest.fixture
def driver():
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
    return driver


def test_pep(driver):  
    driver.get("https://python.org")
    driver.find_element(By.ID, "id-search-field").send_keys("pep")
    driver.find_element(By.ID, "submit").click()
    assert driver.find_element(By.LINK_TEXT, "PEP 1 -- PEP Purpose and Guidelines").text == "PEP 1 -- PEP Purpose and Guidelines"
```

---

## Újrafelhasználás több modulban

`conftest.py`

```python
import pytest
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager


@pytest.fixture
def driver():
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()))
    return driver
```

---

## Automatikus kódkiegészítés

```python
from selenium.webdriver.remote.webdriver import WebDriver

def test_pep(driver: WebDriver):
    """ ... """
```

---

class: inverse, center, middle

# pytest-base-url

---

## pytest-base-url

* https://github.com/pytest-dev/pytest-base-url

`requirements.txt`

```
pytest-base-url
```

```shell
pip install -m requirements.txt
```

---

## Használata

`pytest.ini`


```ini
[pytest]
base_url = https://python.org
```

```python
def test_pep(driver: WebDriver, base_url):
    driver.get(base_url)
```

## join

```python
from urllib.parse import urljoin

driver.get(urljoin(base_url, "/about/apps/"))
```

---

class: inverse, center, middle

# Markers

---

# Skip

```python
@pytest.mark.skip(reason="no way of currently testing this")
```

---

# Saját marker

`pytest.ini` fájlban

```ini
markers = 
    slow
    issue210
```

```python
@pytest.mark.slow
@pytest.mark.issue210
def test_pep(driver: WebDriver, base_url):
    """ ... """
```

```shell
pytest -m "not slow"
pytest -m "slow and issue210"
```

---

class: inverse, center, middle

# report

---

## pytest-html

* A `requirements.txt` fájlba `pytest-html` függőség, majd `pip install -r requirements.txt`

```shell
pytest --html=report.html --self-contained-html
```

---

## Személyre szabás

```python
from datetime import datetime
from py.xml import html
import pytest


def pytest_html_results_table_header(cells):
    cells.insert(2, html.th("Description"))
    cells.insert(1, html.th("Time", class_="sortable time", col="time"))
    cells.pop()


def pytest_html_results_table_row(report, cells):
    cells.insert(2, html.td(report.description))
    cells.insert(1, html.td(datetime.utcnow(), class_="col-time"))
    cells.pop()


@pytest.hookimpl(hookwrapper=True)
def pytest_runtest_makereport(item, call):
    outcome = yield
    report = outcome.get_result()
    report.description = str(item.function.__doc__)
```

---

## Alternatíva

* Allure
* https://qameta.io/allure-report/
* Nem natív Python, Java stack kell hozzá
* Esetleg Dockerben: https://github.com/fescobar/allure-docker-service

---

## Experimental options

```python
from selenium.webdriver.chrome.options import Options

chrome_options = Options()
chrome_options.add_experimental_option("useAutomationExtension", False)
chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])

driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
```


---

class: inverse, center, middle

# Komponensek kijelölése

---

## Komponensek kijelölése

* Id alapján
* Name alapján
* Link szövege alapján
  * Link szövegének egy részlete alapján
* CSS class name
* CSS selector
    * Developer tools/Inspector/Copy CSS selector
* Tag neve alapján
* XPath
    * Developer tools/Inspector/Copy XPath

---

## Egyszerű példa

```java
simple_div = driver.find_element(By.ID, "simple-div");
button = simple_div.find_element(By.NAME, "fullname-input");
```

* `WebDriver` reprezentálja a böngészőt
* `WebElement` reprezentál egy DOM csomópontot
  * `get_attribute()` metódus - visszafele kompatibilitás miatt maradt benne, keveri az attribute és property fogalmát, valamint elég nagy JS megy át a hálózaton
  * `get_dom_attribute()` és `get_dom_property()` megfelelően működik
* `find_element()` mindkettőn meghívható
* `WebElement`-en hívva annak _kontextusában_ keres
* Kontextusban keresés gyorsabb

---

## Több elem keresése

```java
input_elements = driver.find_elements(By.TAG_NAME, "input");
```

---

## XPath

* W3C szabvány
* Egy XML dokumentum elemei és attribútumai közötti navigációt biztosítja
* XPath szintaktika segítségével definiálhatjuk az XML dokumentum részeit
* Kifejezések segítségével mozoghatunk az XML dokumentumban
* https://codebeautify.org/Xpath-Tester
* Kipróbálás: DevTools / Elements / `Ctrl + F`

---

## XPath példák

* `/html`
* `/html/body`
* `//input`
* `/html/@lang`

---

## XPath predicates 1.

* `/html/table/tbody/tr[1]` - első `tr`
* `/html/table/tbody/tr[last()]`  - utolsó `tr`
* `/html/table/tbody/tr[last() - 1]`  - utolsó előtti `tr`
* `/html/table/tbody/tr[position() < 3]` - első két `tr`

---

## XPath predicates 2.

* `//input[@id]` - van `id` attribútuma
* `//input[@id="name-input"]` - `id` attribútumának értéke `name-input`

---

## XPath ismeretlen csomópontok

* `/html/body/*` - összes gyerek
* `//*` - összes elem
* `//*[@id="name-input"]` - összes tag, megadott attribútummal

---

## CSS selector (basic selectors)

* CSS-ben az elemek kijelölésére, melyekre valamilyen formátumot szeretnénk alkalmazni
* W3C CSS specifikáció része
* Kipróbálás: DevTools / Elements / `Ctrl + F`


```plaintext
Lekérdezés id alapján (id selector)
CSS: #example
XPath: //div[@id='example']
```

```plaintext
Lekérdezés tag alapján (type selector)
CSS: input
XPath: //input
```

```plaintext
Lekérdezés class alapján (class selector)
CSS: .example
XPath: //div[@class='example']
```

```plaintext
Lekérdezés attribútum alapján (attribute selector)
CSS: [name='username']
XPath: //div[@name='username']
```

```plaintext
Mindent lekérdez (universal selector)
CSS: *
XPath: //
```

## CSS attribute selectors


* `[attr]` - létező attribútum
* `[attr=value]` - megegyező értékű attribútum
* `[attr~=value]` - szavakból álló attribútum egyik szava
* `[attr|=value]` - értéke vagy a `value`, vagy `value-` és utána bármilyen érték
* `[attr^=value]` - `value` értékkel kezdődik
* `[attr$=value]` - `value` értékkel végződik
* `[attr*=value]` - legalább egyszer tartalmazza
* `[attr operator value i]` - összehasonlítás kis- és nagybetű független (csak ASCII-ra)
* `[attr operator value s] ` - összehasonlítás kis- és nagybetű függő (csak ASCII-ra)

* `id` attribútum alapján: `css=tag#id`, pl. `css=input#name-input`
* CSS class alapján: `css=tag.class`, pl. `css=input.btn`, vagy tag nélkül `.btn`
* Attribútum érték alapján `css=tag[attribute=value]`, pl. `css=input[type=submit]`

---

## Grouping selectors

```plaintext
CSS: div, span
Eredménye: összes div és span csomópont
```

## Combinators

```plaintext
Descendant combinator
CSS: div span
XPath: //div//span
Eredménye: összes div csomópontban lévő span csomópont
```

```plaintext
Child combinator
CSS: div > span
XPath: //div/span
Eredménye: összes közvetlenül a div csomópontban lévő span csomópont
```

```plaintext
General sibling combinator
CSS: div ~ span
Eredménye: span csomópont, ami testvérként követi a div csomópontot
```

```plaintext
Adjacent sibling combinator
CSS: div + span
XPath: //div/following-sibling:span[1]
Eredménye: span csomópont, ami testvérként közvetlenül követi a div csomópontot
```

```plaintext
Column combinator
CSS: col || td
Eredménye: a col csomóponthoz tartozó összes td csomópont
```

## Pseudo classes

```plaintext
Pseudo classes - nem részei a DOM fának
CSS: a:visited
Eredménye: összes meglátogatott a csomópont
```

https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

```plaintext
CSS: #recordlist li::nth-of-type(4)
Eredmény: negyedik li gyermeke a #recordlist csomópontnak
CSS: #recordlist li::nth-child(4)
Eredmény: negyedik gyermeke a #recordlist csomópontnak, ha az li csomópont
CSS: #recordlist *::nth-child(4)
Eredmény: negyedik gyermeke független a típusától
```

```plaintext
Pseudo elements - HTML-ben nem szereplő elemek
CSS: p::first-line
Eredménye: p csomópont első sora
```

https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements

---

## Locator best practices

* Ahol lehet kérdezzünk le id alapján, mert gyors és egyértelmű
* Ha id nincs, akkor preferáljuk a CSS selector használatát
* Az XPath nagyon kifejező, de bonyolult a szintaxis, és általában a böngészőkben 
    nincs teljesítményhangolva, így lassú lehet
* Link szövege alapján csak linket lehet találni
* Tag neve alapján veszélyes lehet, hiszen tipikusan több 

---

class: inverse, center, middle

# Navigáció

---

## Navigáció

```java
driver.get("https://selenium.dev");

driver.current_url;
driver.back();
driver.forward();
```

---

## Screenshot

```python
driver.save_screenshot("main.png")

button = driver.find_element(By.ID, "message-div")
button.screenshot("div.png")

button.click()
```

* `stale element reference: element is not attached to the page document`

Megoldás: `screenshot()` hívása után újra le kell kérni

```python
button = driver.find_element(By.ID, "message-div")
```

---

## Újrafelhasználás, page object

---

## Adatvezérelt tesztelés


---

## Legjobb gyakorlatok

* Körültekintően nevezzük el a teszteket
* Selectornál támaszkodjunk az `id` értékekre, fejlesztők támogatása szükséges
  * `id` elnevezés legyen konzekvens (elnevezési konvenció)
* Idempotens és izolált
* Tesztesetek legyenek egyszerűek
* DRY - don't repeat yourself
* Használjuk Continuous Integration rendszeren belül

---

## Idempotencia és izoláltság

* Tesztesetek egymásra hatással vannak
    * Állapot: pl. adatbázis
* Ugyanazon tesztkörnyezeten több tesztelő vagy harness dolgozik
* Megoldás:
    * Teszteset "rendet tesz" maga előtt, un. set-up
    * "Rendet tesz" maga után, un. tear down
    * Test fixture
        * Legszélsőségesebb megoldás: adatbázistörlés
